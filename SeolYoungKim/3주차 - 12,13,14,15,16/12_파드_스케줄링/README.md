# 12. 파드 스케줄링
> 쿠버네티스에서는 파드를 어떤 노드에 실행할 것인지에 관한 다양한 옵션이 있음 
> - 이를 이용해서 파드 스케줄링이 가능함 

## 1) 노드 셀렉터(nodeSelector)
- `.spec` 필드에 설정할 수 있는 옵션
- 노[..](..)드의 레이블에 설정된 값으로 노드를 선택 
  - node에 key=value 쌍을 추가 레이블링 → Pod 설정 파일에 `.spec.nodeSelector.key=value` 추가해서 특정 노드를 지정하여 사용 

---

## 2) 어피니티와 안티 어피니티 
- 어피니티: 파드들을 함께 묶어서 같은 노드에서 실행 
- 안티 어피니티: 파드들을 다른 노드에 나누어서 실행

### 노드 어피니티 
- 노드 셀렉터와 비슷하게 노드의 레이블 기반으로 파드를 스케줄링 
- 노드 어피니티와 노드 셀렉터를 함께 설정할 수 있음 → 노드 어피니티와 노드 셀렉터 조건을 모두 만족하는 노드에 파드를 스케줄링 
- 필드
  - `requiredDuringSchedulingIgnoredDuringExecution`: 스케줄링하는 동안 **꼭 필요한** 조건 (반드시 만족)
  - `preferredDuringSchedulingIgnoredDuringExecution`: 스케줄링하는 동안 **만족하면 좋은** 조건 (반드시 만족하진 않아도 됨)
    - `weight` 필드를 이용해서, 매치되는 항목마다 카운트(이전값+weight) → 해당 값이 가장 큰 노드 선택 
  - 두 필드는 실행 중 조건이 바뀌어도 무시한다.
    - 파드가 이미 스케줄링되어 특정 노드에서 실행 중인 경우, 중간에 해당 노드의 조건이 변경되더라도 이미 실행 중인 파드는 그대로 실행됨 
  - `.key`: 노드의 레이블 키 중 하나를 설정 (`beta.kubernetes.io/os`로 작성하면, 해당 값을 확인한다.)
  - `.operator`: `.key`가 만족할 조건 
    - `In`: `values[]` 필드에 설정한 값 중, 레이블에 있는 값과 일치하는 것이 하나라도 있는지 확인 
    - `NotIn`: `In`과 반대 
    - `Exists`: `values[]`필드가 필요 없음. `.key` 필드에 설정한 값이 레이블에 있느냐만 확인 
    - `DoesNotExists`: `Exists` 반대 
    - `Gt`: Greater than. `values[]`에 설정된 값보다 큰 숫자형 데이터인지 확인
    - `Lt`: Lower than. `values[]`에 설정된 값보다 작은 숫자형 데이터인지 확인


### 파드의 어피니티와 안티 어피니티 
- 파드 간 어피니티, 안티 어피니티는 디플로이먼트나 스테이트풀세트로 파드를 배포했을 때 개별 파드 사이의 관계를 정의하는 용도로 사용 
- 컨테이너로 서비스를 운영할 때
  - 파드 간에 자주 통신할 때가 있음
  - 이 때, 어피니티를 이용해서 해당 파드들을 같은 노드에 속하게 만들어 효율 증대 
  - ex: 데이터베이스, 캐시, 서비스를 같은 노드에 두어 네트워크 통신 비용 절감 


- 안티 어피니티: 여러 노드로 파드를 분산시키는 것
  - CPU, 네트워크와 같은 하드웨어 자원을 많이 사용하는 앱 컨테이너가 있는 경우 사용
  - 안티 어피니티를 설정하지 않으면 디플로이먼트로 배포한 파드가 노드 하나에서만 실행 → 노드 내에 한정된 많은 자원 소모 → 효과가 없거나 악효과를 미침 


- 쿠버네티스는 파드를 스케줄링할 때 먼저 파드의 레이블 기준으로 대상 노드를 찾음
  - 그리고 `.topologyKey` 필드를 확인해서 해당 노드가 원하는 노드인지를 확인 


---

## 3) 테인트와 톨러레이션 사용하기 
- 테인트(taint)
  - 테인트를 설정한 노드에는 파드들을 스케줄링하지 않음 
  - 테인트를 설정한 노드에 파드들을 스케줄링하기 위해서는 **톨러레이션(toleration)**을 설정해야 함 
  - 테인트는 톨러레이션에서 설정한 특정 파드들만 실행하고, 다른 파드들은 실행하지 못하게 함 

### 사용 목적
- 노드를 특정 역할만 하도록 만들 때 사용 
  - ex: db용 파드 실행 → 노드 전체의 CPU나 RAM을 독점해서 사용할 수 있도록 설정 
  - ex2: GPU가 있는 노드에는 실제로 GPU를 사용하는 파드들만 실행되도록 설정 

### 하위 필드
- `.effect`
  - `NoSchedule`: 톨러레이션 설정이 없는 경우 파드를 스케줄링하지 않음. 기존 실행되던 파드에는 적용되지 않음.
  - `PreferNoSchedule`: 톨러레이션 설정이 없는 경우 파드를 스케줄링하지 않음. 하지만, 클러스터 안 자원이 부족할 경우 테인트를 설정한 노드에서도 파드를 스케줄링할 수 있음 
  - `NoExecute`: 톨러레이션 설정이 없는 경우 새로운 파드를 스케줄링하지 않음. 기존 파드도 톨러레이션 설정이 없는 경우 종료.
- `.operator`
  - `Equal`: 같은거만 실행 
  - `Exists`: 어떤 테인트 설정이 있든 파드를 스케줄링해서 실행 
  

---

## 4) 클러스터를 관리하는 커든과 드레인
- cordon & drain 
  - 특정 노드에 있는 파드들을 모두 다른 노드로 옮기거나 특정 노드에 파드들을 스케줄링하지 않도록 제한하는 기능 제공

### 커든(cordon)
- 지정된 노드에 추가로 파드를 스케줄링해서 실행하지 않도록 설정 


### 드레인(drain)
- 노드 관리 등의 이유로 지정된 노드에 있는 파드들을 다른 노드로 이동시키는 명령 
- 먼저 새로운 파드를 노드에 스케줄링해서 실행하지 않도록 설정
  - 그 다음, 기존 해당 노드에서 실행 중이던 파드들을 삭제 
- 노드에 데몬세트로 실행한 파드들이 있는 경우 드레인 설정 적용 불가
  - 데몬세트로 실행한 파드들은 삭제해도 데몬세트가 즉시 재실행시키기 때문 
- 컨트롤러를 이용하지 않고 실행한 파드들 또한 드레인 설정 불가
  - 컨트롤러가 관리하는 파드 → 삭제되더라도 컨트롤러가 클러스터 안 다른 노드에 같은 역할을 하는 파드를 재실행 
  - 컨트롤러를 이용하지 않고 실행한 파드들은 한 번 삭제되면 복구 불가 → 중요한 역할을 하는 파드 삭제를 막기 위해 드레인 설정을 적용할 수 없는 것 
- kubelet이 직접 실행한 스태틱 파드들
  - `kube-apiserver` 컴포넌트를 이용해 실행하지 않아 삭제되지 않음 
  - 드레인 설정을 적용할 경우, graceful하게 파드들을 종료 → 기존 작업을 정리한 후 종료 → 드레인 설정은 이 과정을 모두 기다림 


